server:
  port: 8090
debug: false
logging.level.org.springframework.boot.autoconfigure:  debug
logging.level.com.roncoo.eshop.mapper: debug
spring:
  datasource:
    url: jdbc:mysql://196.128.133.130:3306/eshop?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver

  #redis集群
  redis:
    cluster:
      nodes:
        - 196.128.133.133:7001
        - 196.128.133.133:7002
        - 196.128.133.128:7003
        - 196.128.133.128:7004
        - 196.128.133.129:7005
        - 196.128.133.129:7006
    database: 0
    timeout: 1000

  #本地缓存
  cache:
    type: ehcache
    ehcache:
      config: classpath:ehcache.xml

  kafka:
    #指定kafka服务器地址
    bootstrap-servers: http://196.128.133.133:9092,http://196.128.133.128:9092,http://196.128.133.129:9092
    #生产者
    producer:
      # 重试次数，默认Integer.MAX_VALUE
      retries: 3
      # ack应答机制，默认1，即只需要确认leader收到消息
      acks: all
      # 同一批次内存大小（默认16K）
      batch-size: 16384
      # 生产者内存缓存区大小(32M)
      buffer-memory: 33554432
      # key和value的序列化（默认，可以不设置）
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: com.roncoo.eshop.cache.serializable.KafkaMessageSerializable
      #properties:
        # 使用自定义的分区选择器
        #{partitioner.class: com.msy.kafka.MyPartition, acks: all}
    #消费者
    consumer:
      # 消费组，和 topic 是一一对应的，例如，topic里的一个消息只能被一个消费组消费一次，如果在一个消费组里有多个消费者，则采用load balanced的方式消费，如果所有的消费者都不属于同一个消费组，则订阅该topic的消息所有的消费者都会接收到消息，消费组的概念是为了补充多个消费者竞争分割的处理消息
      # 消费者群组ID，发布-订阅模式，即如果一个生产者，多个消费者都要消费，那么需要定义自己的群组，同一群组内的消费者只有一个能消费到消息
      group-id: eshop-cache-group
      # earliest：从头开始消费   latest：从最新的开始消费   默认latest
      auto-offset-reset: earliest
      enable-auto-commit: false
      # key和value反序列化（默认，可以不设置）
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      max-poll-records: 20000
    #监听器
    listener:
      # 消费者并发能力
      concurrency: 3
      # 设置手动提交的时候，需要设置ackMode
      ack-mode: MANUAL

#topic, 也可以在模板发送的时候写在代码里：kafkaTemplate.send("testTopic","message");
kafka.eshop.topic: test_topic
kafka.eshop.cacheTopic: eshop-cache




